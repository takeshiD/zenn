---
title: "Arch Linuxメモ パーティション GPT"
emoji: "💬"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["linux", "arch"]
published: true
---

Arch Linuxを触ったときに調べたことをメモしていきます。

# パーティションの基礎(続き)
前回はMBRの設定を/dev/sdaに適用して`hexdump`で内容を見ました。  
今回は近年主流のパーティション管理方法であるGUIDパーティション(GPT)を見ていきましょう。

:::message
`parted`コマンドを使用します。
`fdisk`は(調べた限りでは)GPTには対応していないようなので`parted`を使いましょう。  
`gdisk`というコマンドはGPTに対応しているのでこちらでも良さそうです。ですがこの記事では解説しませんのでご理解下さい。
:::

## GUIDパーティションテーブル(GPT)
ストレージのパーティション管理方法をGPTにすると、ストレージは次のような構造になります(Wikipediaより引用)。

![引用Wikipedia](/images/GUID_Partition_Table.png)

注目する点は次になります。
* LBA(Logical Block Addressing)という番号で場所を管理する
* LBAのサイズは512Byteで固定ではない
* MBRで起動してしまったときのために、LBA0に保護用MBRがある
* MBRの次が(第1)GPTヘッダー
* (第1)GPTヘッダのバックアップのため、ストレージ終端に第2GPTヘッダーがある

説明を長々読んでも実感が得られないので実際にGPTを見てみましょう。

## デバイスをGPTに初期化する
まずは`parted`を使用して`mklabel gpt`を実行し、`quit`で抜けます。
```sh
$ parted /dev/sda
GNU Parted 3.4
Using /dev/sda
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) mklabel gpt
(parted) quit
```
これで/dev/sdaがGPTで初期化されました。

## 保護用MBR
`hexdump`で/dev/sdaを見てみましょう。まずは先頭にMBRがあるか見てみます。
保護用MBRとのことですが、通常のMBRとどう違うのでしょうか。
```
hexdump /dev/sda -s 0 -n 512
```
今回は`-v`オプション無しです。
:::details hexdumpのオプション
* `-s` : 開始アドレス　未指定の場合は0になる
* `-n` : 読み込み長さ(Byte) 今回は512Byteを読み込み
* `-v` : 表示を省略しない指定。未指定だと同じ値を`*`で省略される。
:::

```:hexdump出力結果
0000000 0000 0000 0000 0000 0000 0000 0000 0000
*
00001c0 0002 ffee ffff 0001 0000 ffff 027f 0000
00001d0 0000 0000 0000 0000 0000 0000 0000 0000
*
00001f0 0000 0000 0000 0000 0000 0000 0000 aa55
0000200
```
MBRで初期化した場合は0000000～0000040に機械語が書かれていましたが、GPTの場合はまっさらです。  
しかし第1パーティションテーブルには値が入ってます。
```:第1パーティションテーブル
00001b0                                    0000
00001c0 0002 ffee ffff 0001 0000 ffff 027f 
```

| アドレスオフセット | 内容 | サイズ | 今回の値(hex) | 解釈 |
|---|---|---|---|---|
| 0x00 | ブートフラグ | 1Byte | 00 | ブート不可 |
| 0x01 | パーティション開始セクタ(CHS方式) | 3Byte | 00 02 00 |  | 
| 0x04 | パーティション識別子 | 1Byte | ee | GPT |
| 0x05 | パーティション終了セクタ(CHS方式) | 3Byte | ff ff ff | |
| 0x08 | パーティション開始セクタ(LBA方式) | 4Byte | 00 00 00 01 | 1セクタ目 |
| 0x0c | パーティション全セクタ数 | 4Byte | 7f 02 ff ff | 2TiBセクタ分 |

識別子がGPTになってます。開始セクタ(LBA)が1セクタ目を指してますね。  
特に意味の無さそうな内容です。これが保護用MBRなんでしょうか。
どう保護されているのかよく分かってないので今度調べてみます。

00001f0を見てみると、終端にaa55(MBRブートシグネチャ)がありますのでMBRであることが分かります。

まあこんなもんかという気持ちになったところでGPTヘッダを見てみます。

## 第1GPTヘッダ
512Byte目から512Byte分が第1GPTヘッダです。

`hexdump`で見てみましょう。
```
hexdump /dev/sda -s 512 -n 512
```
:::details hexdumpのオプション
* `-s` : 開始アドレス　未指定の場合は0になる
* `-n` : 読み込み長さ(Byte) 今回は512Byteを読み込み
* `-v` : 表示を省略しない指定。未指定だと同じ値を`*`で省略される。
:::

```:第1GPTヘッダー
0000200 4645 2049 4150 5452 0000 0001 005c 0000
0000210 0596 75b7 0000 0000 0001 0000 0000 0000
0000220 ffff 027f 0000 0000 0022 0000 0000 0000
0000230 ffde 027f 0000 0000 c8d3 50d1 865b 4408
0000240 0798 38a5 e315 de9b 0002 0000 0000 0000
0000250 0080 0000 0080 0000 d286 ab54 0000 0000
0000260 0000 0000 0000 0000 0000 0000 0000 0000
*
0000400
```
GPTヘッダーは次のような構造になっています。[英語のWikipedia](https://en.wikipedia.org/wiki/GUID_Partition_Table)がわかりやすいです。

| 開始アドレス | 終端アドレス | 内容  | サイズ |
| ----------- | ----------- | ---- | ------ |
| 0x0200  | 0x0207 | シグネチャ | 8Byte |
| 0x0208  | 0x020b | リビジョン | 4Byte |
| 0x020c  | 0x020f | ヘッダサイズ | 4Byte |
| 0x0210  | 0x0213 | CRC32ヘッダ | 4Byte |
| 0x0214  | 0x0217 | 予約(0埋め) | 4Byte |
| 0x0218  | 0x021f | 第1GPTヘッダのLBA | 8Byte |
| 0x0220  | 0x0227 | 第2GPTヘッダのLBA | 8Byte |
| 0x0228  | 0x022f | 最初の使用可能なパーティションのLBA | 8Byte |
| 0x0230  | 0x0237 | 最後の使用可能なパーティションのLBA | 8Byte |
| 0x0238  | 0x0247 | Disk GUID | 16Byte |
| 0x0248  | 0x024f | パーティションエントリー配列の先頭LBA | 8Byte |
| 0x0250  | 0x0253 | 配列のパーティションエントリーの数 | 4Byte |
| 0x0254  | 0x0257 | 単一パーティションエントリーのサイズ | 4Byte |
| 0x0258  | 0x025B | パーティションエントリー配列のCRC32 | 4Byte |
| 0x025c  | 0x03ff | 予約(0埋め) | 残り全部Byte |

いっぱいあって読む気が失せますが、ちょっとずつ読んでいきます。OSのブートとかデバイス関連って根性な部分が多い気がする、、、

### シグネチャ(8Byte)
EFIを表すシグネチャです。
45 46 49 20 50 41 52 54　で固定です。
```:シグネチャ
0000200 4645 2049 4150 5452
```

### リビジョン(4Byte)
UEFIのリビジョン(改定)番号です。00 00 01 00 = 1.0で固定のようです。

```:リビジョン
0000200                     0000 0001
```

### ヘッダサイズ(4Byte)
GPTヘッダのサイズを表します。
00 00 00 5c = 92Byte が通常のようです。
```:ヘッダサイズ
0000200                               005c 0000
```

### ヘッダCRC32(4Byte)
ヘッダの破損を検知する[巡回冗長検査(CRC, Cyclic Redundancy Check)](https://ja.wikipedia.org/wiki/%E5%B7%A1%E5%9B%9E%E5%86%97%E9%95%B7%E6%A4%9C%E6%9F%BB)のデータです。32なので32bit(4Byte)のようですね。
[GUID Patition Table](https://en.wikipedia.org/wiki/GUID_Partition_Table)に計算中は0になると書いてありますが、どういうことなのかよくわかってません。
```:ヘッダCRC32
0000210 0596 75b7
```

### 予約(0埋め)(4Byte)
ここは必ず0埋めとのこと。
```:予約(0埋め)
0000210           0000 0000
```

### 第1GPTヘッダのLBA(8Byte)
第1GPTヘッダのLBAを格納しています。0000 0000 0000 0001 = 1セクタ目 = 512Byte目 を表しています。
```:第1GPTヘッダのLBA
0000210                     0001 0000 0000 0000
```

### 第2GPTヘッダのLBA(8Byte)
第1GPTヘッダのバックアップ用の第2GPTヘッダのLBAを格納しています。  
```:第1GPTヘッダのLBA
0000220 ffff 027f 0000 0000
```
0000 0000 027f ffff = 41943039セクタ目 = 21474835968Byte = 20479MiB を表しています。
今回の仮想VirtualBoxストレージを20GBで作成したので、終端に作成されていることが分かります。

### 最初の使用可能なパーティションのLBA(8Byte)
```
0000220                     0022 0000 0000 0000
```

### 最後の使用可能なパーティションのLBA(8Byte)
```
0000230 ffde 027f 0000 0000
```

:::message
書き途中ですが一旦アップ
:::